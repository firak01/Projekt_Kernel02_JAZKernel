package basic.zKernel.file;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Calendar;
import java.util.GregorianCalendar;

import basic.zBasic.ExceptionZZZ;
import basic.zBasic.ReflectCodeZZZ;
import basic.zBasic.util.datatype.string.StringZZZ;
import basic.zKernel.IKernelZZZ;
import basic.zKernel.KernelUseObjectZZZ;
import basic.zKernel.flag.IFlagZUserZZZ;
import basic.zUtil.io.IFileExpansionZZZ;
import basic.zKernel.IKernelZZZ;


import custom.zKernel.*;
import custom.zUtil.io.*;



/**
Class, which copies one or more file(s) from one directory to another.

The goal is:
- to copy the file(s) to a domino-server, where they can be processed by the Z-Kernel import routine (written in lotusscript)
- to copy the file(s), which were generated by the Z-Kernel export routine (written in lotusscript), from a domino-server to a foreign directory (might using an unc-path)

Remark: This class doesn�t need any notes-classes and can also be used for normal copying without any domino-Server/Notes-Client involved !!! 

@author 0823 ,date 01.10.2004
 */
public class KernelFileTextCopyZZZ   extends KernelUseObjectZZZ{
	private boolean bFlagSourceRemove;
	private boolean bFlagSourceRename;
	private String sDirectoryTarget;
	private String sDirectorySource;
	private String[] saFileTarget;
	private String[] saFileSource;

	//Constructor	
	public KernelFileTextCopyZZZ(IKernelZZZ objKernelIn, LogZZZ objLogIn, String sDirectorySourceIn, String sDirectoryTargetIn,String[] saFileSourceIn, String[] saFileTargetIn, String[] saFlagControl) throws ExceptionZZZ{
		KernelFileTextCopyNew_(objKernelIn, objLogIn, sDirectorySourceIn, sDirectoryTargetIn,saFileSourceIn, saFileTargetIn, saFlagControl);
	}
	
	//TODO: Constuctor erstellen, der ein Array von Dateien(incl. Pfad) bekommt und diese in das Zielverzeichnis kopiert !!!!
	
	/** ++++++++++++++++++++++++++++++++++++++++++
	
	 @author 0823 , date: 15.10.2004
	 @param objKernelIn
	 @param objLogIn
	 @param sDirectorySourceIn
	 @param sDirectoryTargetIn
	 @param saFlagControl
	 @return
	 */
	private boolean KernelFileTextCopyNew_(IKernelZZZ objKernelIn, LogZZZ objLogIn, String sDirectorySourceIn, String sDirectoryTargetIn, String[] saFileSourceIn, String[] saFileTargetIn, String[] saFlagControl) throws ExceptionZZZ {
		boolean bReturn = false;
		main:{
			String stemp;	boolean btemp;
				
			this.setKernelObject(objKernelIn);
			if(objLogIn==null){
				this.setLogObject(objKernelIn.getLogObject());
			}else{
				this.setLogObject(objLogIn);	
			}
			
			
			if(saFlagControl != null){
						for(int iCount = 0;iCount<=saFlagControl.length-1;iCount++){
							stemp = saFlagControl[iCount];
							btemp = setFlag(stemp, true);
							if(btemp==false){ 								   
								   ExceptionZZZ ez = new ExceptionZZZ( IFlagZUserZZZ.sERROR_FLAG_UNAVAILABLE + stemp, IFlagZUserZZZ.iERROR_FLAG_UNAVAILABLE, this, ReflectCodeZZZ.getMethodCurrentName()); 
								   //doesn�t work. Only works when > JDK 1.4
								   //Exception e = new Exception();
								   //ExceptionZZZ ez = new ExceptionZZZ(stemp,iCode,this, e, "");
								   throw ez;		 
							}
						}
					}
					if(this.getFlag("INIT")==true){
																bReturn = true;
																break main; 
															}		
			
					
			//Falls das SourceDirectory null ist, wird davon ausgegangen, dass saFileSource die Pfade enth�lt
			if(sDirectorySourceIn == null){
				//Falls saFileSource null ist, Fehler
				if(saFileSourceIn==null){
					stemp = "Source-Filename-Array' or 'Source-Directory'";
				   ExceptionZZZ ez = new ExceptionZZZ(stemp, iERROR_PARAMETER_MISSING, this, ReflectCodeZZZ.getMethodCurrentName()); 
				   //doesn�t work. Only works when > JDK 1.4
				   //Exception e = new Exception();
				   //ExceptionZZZ ez = new ExceptionZZZ(stemp,iCode,this, e, "");
				   throw ez;	
				}
				this.saFileSource = saFileSourceIn;
				this.sDirectorySource = sDirectorySourceIn;
				
			}else{
				//Falls saFileSource null ist, werden alle Dateien des Verzeichnisses verwendet
				if(saFileSourceIn==null){
					File objFileDirSource = new File(sDirectorySourceIn);
					//Falls das kein Verzeichnis ist, Fehler
					if(objFileDirSource.exists()==false){
						stemp = "directory does not exist 'Source-Directory': " + sDirectorySourceIn;				
					   ExceptionZZZ ez = new ExceptionZZZ(stemp, iERROR_PARAMETER_VALUE, this, ReflectCodeZZZ.getMethodCurrentName()); 
					   //doesn�t work. Only works when > JDK 1.4
					   //Exception e = new Exception();
					   //ExceptionZZZ ez = new ExceptionZZZ(stemp,iCode,this, e, "");
					   throw ez;
					}
					if(objFileDirSource.isDirectory()==false){
						stemp = "this is no directory 'Source-Directory': " + sDirectorySourceIn;
					   ExceptionZZZ ez = new ExceptionZZZ(stemp, iERROR_PARAMETER_VALUE, this, ReflectCodeZZZ.getMethodCurrentName()); 
					   //doesn�t work. Only works when > JDK 1.4
					   //Exception e = new Exception();
					   //ExceptionZZZ ez = new ExceptionZZZ(stemp,iCode,this, e, "");
					   throw ez;
					}			
					
					this.saFileSource = objFileDirSource.list();
				}else{
					this.saFileSource = saFileSourceIn;		
				}				
				this.sDirectorySource = sDirectorySourceIn;	
			}
			
			//Falls das TargetDirectory null ist, wird davon ausgegangen, saFileTarget die Pfade enth�lt
			if(sDirectoryTargetIn == null){
				//Darum ist es ein Fehler, wenn keine Zieldateien angegeben wurden!!!
				if(saFileTargetIn==null){
					stemp = "missing parameter 'Target-Filename-Array' or 'Target-Directory'";
				   ExceptionZZZ ez = new ExceptionZZZ(stemp, iERROR_PARAMETER_MISSING, this,ReflectCodeZZZ.getMethodCurrentName()); 
				   //doesn�t work. Only works when > JDK 1.4
				   //Exception e = new Exception();
				   //ExceptionZZZ ez = new ExceptionZZZ(stemp,iCode,this, e, "");
				   throw ez;	
				}
				
				//Falls das Mapping der Source-Dateinamen zu den Target-Dateinamen unterschiedlich ist, Fehler
				if(saFileTargetIn.length != saFileSource.length){
					stemp = "different array-length: 'Mapping Source-Files to Target-Files' not possible";
				   ExceptionZZZ ez = new ExceptionZZZ(stemp, iERROR_PARAMETER_VALUE, this, ReflectCodeZZZ.getMethodCurrentName()); 
				   //doesn�t work. Only works when > JDK 1.4
				   //Exception e = new Exception();
				   //ExceptionZZZ ez = new ExceptionZZZ(stemp,iCode,this, e, "");
				   throw ez;	
				}
				
				
				sDirectoryTarget = null;	
				saFileTarget = saFileTargetIn;			
			}else{
				sDirectoryTarget = sDirectoryTargetIn;
				
				//Falls Kein Mapping zu irgendwelchen Dateinamen existiert, werden die eingangsdateinamen verwendet.
				if(saFileTargetIn == null){
					saFileTarget = saFileSourceIn;
				}else{
					saFileTarget = saFileTargetIn;	
				}
			}				
		}
		return bReturn;		
	}//end function 

	/**
	 * @see zzzKernel.basic.KernelUseObjectZZZ#setFlag(java.lang.String, boolean)
	 * @param sFlagName
	 * 			  source_rename: after copying the source_files will be renamed.
	 * 			  source_remove: after copying the source_files will be removed.
	 */
	public boolean setFlag(String sFlagName, boolean bFlagValue){
		boolean bFunction = false;
		main:{
			if(StringZZZ.isEmpty(sFlagName)) break main;
			bFunction = super.setFlag(sFlagName, bFlagValue);
			if(bFunction==true) break main;
	
		//setting the flags of this object
		String stemp = sFlagName.toLowerCase();
		if(stemp.equals("source_rename")){
			bFlagSourceRename = bFlagValue;
			bFunction = true;
			break main;
		}else if(stemp.equals("source_remove")){
			bFlagSourceRemove = bFlagValue;
			bFunction = true;
			break main;
		}
		}//end main:
		return bFunction;
	}
	
	public boolean getFlag(String sFlagName){
		boolean bFunction = false;
		main:{
			if(StringZZZ.isEmpty(sFlagName)) break main;
			bFunction = super.getFlag(sFlagName);
			if(bFunction==true) break main;
			
			//getting the flags of this object
			String stemp = sFlagName.toLowerCase();
			if(stemp.equals("source_rename")){
				bFunction = bFlagSourceRename;
				break main;
			}else if(stemp.equals("source_remove")){
				bFunction = bFlagSourceRemove;
				break main;
			}
		}//end main:
		return bFunction;
	}
	
	

	
	



	/* (non-Javadoc)
	 * @see zzzKernel.basic.KernelAssetObjectZZZ#getExceptionObject()
	 */
	public ExceptionZZZ getExceptionObject() {
		return objException;
	}


	/* (non-Javadoc)
	 * @see zzzKernel.basic.KernelAssetObjectZZZ#setExceptionObject(zzzKernel.custom.ExceptionZZZ)
	 */
	public void setExceptionObject(ExceptionZZZ objExceptionIn) {
		objException = objExceptionIn;
	}








	/* (non-Javadoc)
	 * @see zzzKernel.basic.KernelAssetKernelZZZ#getKernelObject()
	 */
	public IKernelZZZ getKernelObject() {
		return objKernel;
	}


	/* (non-Javadoc)
	 * @see zzzKernel.basic.KernelAssetKernelZZZ#setKernelObject(zzzKernel.custom.KernelZZZ)
	 */
	public void setKernelObject(IKernelZZZ objKernelIn) {
		objKernel = objKernelIn;
	}


	/* (non-Javadoc)
	 * @see zzzKernel.basic.KernelAssetKernelZZZ#getLogObject()
	 */
	public LogZZZ getLogObject() {
		return objLog;
	}


	/* (non-Javadoc)
	 * @see zzzKernel.basic.KernelAssetKernelZZZ#setLogObject(zzzKernel.custom.LogZZZ)
	 */
	public void setLogObject(LogZZZ objLogIn) {
			objLog = objLogIn;
	}// end function

	/**
	 * beginn copying the files
	 * @author 0823
	 */
	public boolean startit(String[] saFlagControl) throws ExceptionZZZ{
		boolean bFunction = false;		
		main:{
			int iCode; String stemp; String sMethod;
			File objFileTemp;File objDirTemp;
			LogZZZ objLog;
			boolean bFlagAnyFileProcessed = false;
			check:{
				if(saFileSource==null){
						stemp = "missing property 'Source-Filename-Array'";
					   ExceptionZZZ ez = new ExceptionZZZ(stemp, iERROR_PARAMETER_MISSING, this, ReflectCodeZZZ.getMethodCurrentName()); 
					   //doesn�t work. Only works when > JDK 1.4
					   //Exception e = new Exception();
					   //ExceptionZZZ ez = new ExceptionZZZ(stemp,iCode,this, e, "");
					   throw ez;	
				}
				if(saFileTarget==null & sDirectoryTarget==null){
					stemp = "missing property 'TargetDirectory' / 'Target - Filename - Array";
					 ExceptionZZZ ez = new ExceptionZZZ(stemp, iERROR_PARAMETER_MISSING, this, ReflectCodeZZZ.getMethodCurrentName()); 
					   //doesn�t work. Only works when > JDK 1.4
					   //Exception e = new Exception();
					   //ExceptionZZZ ez = new ExceptionZZZ(stemp,iCode,this, e, "");
					   throw ez;	
				}
				if(saFileTarget==null){
						stemp = "missing property 'Target-Filename-Array'";
					   ExceptionZZZ ez = new ExceptionZZZ(stemp, iERROR_PROPERTY_MISSING , this, ReflectCodeZZZ.getMethodCurrentName()); 
					   //doesn�t work. Only works when > JDK 1.4
					   //Exception e = new Exception();
					   //ExceptionZZZ ez = new ExceptionZZZ(stemp,iCode,this, e, "");
					   throw ez;	
				}
				if(this.getLogObject()==null){
					objLog = this.getKernelObject().getLogObject();
				}else{
					objLog = this.getLogObject();
				}
				
			}//end check:
			
			//#####   Just copy the files 1:1 to the target directory  ################################################
			String sFileSourceBasis;
			String sFileTargetBasis;
			String sFileSourceExpanded;
			String sFileTargetExpanded;
			String sDirectoryTargetFinal;String sDirectorySourceFinal;
			for(int i = 0; i <= saFileSource.length-1; i++){
     		  handlefile:{ //damit man zur n�chsten datei gehen kann mit break!!!
       			
       			  //+++ Source-Dateiname (als Basis)
				  if(saFileSource[i] == null){
				  	break handlefile;
				  } 					  
				  if(saFileSource[i].equals("")){
				  	break handlefile;
				  }				  
				objFileTemp = new File(saFileSource[i]);
				sFileSourceBasis = objFileTemp.getName(); 
				   	
				 
				   //+++ Target-Directory
				   if(sDirectoryTarget==null){
				   		//Fall: Target-Directory im Dateinamen
				   	    objFileTemp = new File(saFileTarget[i]);
						stemp = objFileTemp.getParent();
						objDirTemp = new File(stemp); 		
				   	    
				   	    //TODO erzeugen dieses fehlenden Verzeichnisses statt, ignorieren der Verarbeitung
				   	    if(objDirTemp.exists()==false){
				   	        objLog.WriteLineDate("target directory defined by File-Name-Array Property does not exist, skipping file: '" +saFileTarget[i]);
				   	    	break handlefile;
				   	    }
				   	    if(objDirTemp.isDirectory()==false){
				   	    	objLog.WriteLineDate("target directory defined by File-Name-Array Property is not a directory, skipping file: '" + saFileTarget[i]);
				   	    	break handlefile;
				   	    }
					sDirectoryTargetFinal = objFileTemp.getPath();
					
				   }else{
				   		//Fall: Target-Directory explizit �bergeben
				   		sDirectoryTargetFinal = sDirectoryTarget; 
				   }
				   
				   //+++ Source-Directory
				   if(sDirectorySource==null){
				   		//Fall: Source-Directory im Dateinamen
						objFileTemp = new File(saFileSource[i]);
					   	stemp = objFileTemp.getParent();
						objDirTemp = new File(stemp); 					
					   if(objDirTemp.exists()==false){
						   this.getLogObject().WriteLineDate("source directory defined by File-Name-Array Property does not exist, skipping file: '" +saFileSource[i]);
						   break handlefile;
					   }
					   if(objDirTemp.isDirectory()==false){
						   this.getLogObject().WriteLineDate("source directory defined by File-Name-Array Property is not a directory, skipping file: '" + saFileSource[i]);
						   break handlefile;
					   }
						sDirectorySourceFinal = objDirTemp.getPath();

				   }else
				   		//Fall: Source-Directory explizit �bergeben
				   		sDirectorySourceFinal = sDirectorySource;
						if(saFileTarget[i]==null){
								sFileTargetBasis = sFileSourceBasis;
						}else  if(saFileTarget[i].equals("")){                   //hierdurch kann man definieren, dass der Dateiname gleich sein soll !!!
					   			//Falls in den Source-Dateinamen auch die Verzeichnisse enthalten sind					   			
					   			sFileTargetBasis = sFileSourceBasis;		   
					   }else{
							//Den Zieldateinamen
							objFileTemp = new File(saFileTarget[i]);
							sFileTargetBasis  = objFileTemp.getName();
					   }
				   				
				   if(sFileSourceBasis.length() > 0){	
					   boolean bGotoNextExpansion = true;
					   String sFileSourceExpandedLast = new String("");
					   do{ //Solange es ein Source-File mit einer "Folge"-Expansion gibt, soll kopiert werden.       		        	
						   IFileExpansionZZZ objFileExpansion = new FileExpansionZZZ('0',3);
						   FileZZZ objFileSource = new FileZZZ(sDirectorySourceFinal, sFileSourceBasis, objFileExpansion, null);
						   sFileSourceExpanded = objFileSource.PathNameTotalExpandedFirstCompute();
        					        					
        					objFileTemp = new File(sFileSourceExpanded);        					
        					if(objFileTemp.exists()==false){
								// Falls die letzte SourceDatei schon gel�scht wurde, wird der Originale-Source-Dateiname als Expansion zur�ckgegeben, doch der ist schon l�ngst nicht mehr da.
								bGotoNextExpansion = false;		
        					}else if(sFileSourceExpandedLast.equals(sFileSourceExpanded)){
								//Falls die Source-Datei nicht gel�scht oder umbenannt wurde, wird so die Quelldatei immer wieder aufgegriffen, also:
        						bGotoNextExpansion = false;  //dadurch kommt man dann aus der Schleife raus !!!
        					}else{ 
        						sFileSourceExpandedLast = sFileSourceExpanded;        						
        						FileZZZ objFileTarget = new FileZZZ(sDirectoryTargetFinal, sFileTargetBasis, objFileExpansion, null);
        						sFileTargetExpanded = objFileTarget.PathNameTotalExpandedNextCompute();
        						
        						objLog.WriteLineDate("Kopiere Datei '" + sFileSourceExpanded + "' --> '" + sFileTargetExpanded + "'");
						 
	        
	        
						   // Ziel: Es soll der Agent nicht abbrechen, nur weil er eine Datei nicht findet
						   //Nun eine Datei kopieren
	
							   try{
							   	   File objFileSourceExpanded = new File(sFileSourceExpanded);
								   FileReader fin = new FileReader(objFileSourceExpanded);
								   BufferedReader bfin = new BufferedReader(fin);
					
	   							   File objFileTargetExpanded = new File(sFileTargetExpanded);
								   FileWriter fout = new FileWriter(objFileTargetExpanded);
								   BufferedWriter bfout = new BufferedWriter(fout);
	
								   int c;
								   //ToDo: Verlauf der Kopieraktion protokollieren.
								   while ((c = bfin.read()) != -1) bfout.write(c);
								   //Schliessen der Dateistr�me
									bfin.close();
									bfout.close();
									fin.close();
									fout.close();
	 				 
	 				 			//WAS soll mit der Ausgangsdatei geschehen ?
	 				 			if(getFlag("source_rename")==true){
	 				 				boolean btemp = FileSourceRename((FileZZZ)objFileSourceExpanded, sDirectorySource, sFileSourceExpanded);
									if(btemp == false) objLog.WriteLineDate("Error renaming Source-File: " + objFileSource.getPath());
	 				 			}else if(getFlag("source_remove")==true){
	 				 				boolean btemp = objFileSourceExpanded.delete();
									if(btemp == false) objLog.WriteLineDate("Error deleting Source-File: " + objFileSource.getPath());
	 				 			}
	 				 
								
							   }
							   //Dateibehandlung - Exceptions 				 
							   catch(FileNotFoundException e){
							   		objLog.WriteLine(e.getMessage());
							   		//Es soll weitergehen, darum nicht !!! System.exit(0);
							   }
					
							   //Schreib-/LeseExceptions
							   catch(IOException e){
									objLog.WriteLine(e.getMessage());
									//Es soll weitergehen, darum nicht !!! System.exit(0);
							   }	
        				}//end if sFileExpandedLast != sFileExpanded
					   }while(bGotoNextExpansion == true);
	    	  
						 }//end if sFileSourceBasis <> ""
						bFlagAnyFileProcessed = true;
				  }//end handlefile:
				  }//end for �ber alle Dateien
				  if(bFlagAnyFileProcessed==false) objLog.WriteLineDate("No file found to process.");
		}//end main:
		return bFunction;
	}

	/**
	 * @param objFileSource
	 * @param sDirectorySource
	 * @param sFileSourceExpanded
	 */
	public boolean FileSourceRename(FileZZZ objFileSource, String sDirectorySource, String sFileSourceExpanded) {
			boolean bFunction = false;
			//Umbenennen der Ausgangsdatei 
			GregorianCalendar d = new GregorianCalendar();
			Integer iDateYear = new Integer(d.get(Calendar.YEAR));
			Integer iDateMonth = new Integer(d.get(Calendar.MONTH) + 1);
			Integer iDateDay = new Integer(d.get(Calendar.DAY_OF_MONTH));
			Integer iTimeHour = new Integer(d.get(Calendar.HOUR_OF_DAY));
			Integer iTimeMinute = new Integer(d.get(Calendar.MINUTE)); 			
			String sDate = iDateYear.toString() + "-" + iDateMonth.toString() + "-" + iDateDay.toString()
			+ "_" + iTimeHour.toString() + "_" + iTimeMinute.toString(); 

			File inputFileProcessed = new File(sDirectorySource + "\\von_Notes_kopiert_am_" + sDate + "_" + sFileSourceExpanded);
			bFunction = objFileSource.renameTo(inputFileProcessed);
			return bFunction;	 			
	}

} //end class
