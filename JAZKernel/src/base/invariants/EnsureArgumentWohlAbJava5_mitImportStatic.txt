package base.invariants;

import java.io.File;
import java.util.Collection;
import java.util.Map;

import org.apache.commons.lang.ObjectUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.Validate;

/*
import static com.google.common.collect.Sets.newHashSet;
import static de.his.core.base.invariants.EnsureState.getTargetClass;
import static de.his.core.base.invariants.EnsureState.getTargetObject;
import static de.his.core.base.invariants.ViolationCheck.illegalArgumentException;
import static de.his.core.base.invariants.ViolationCheck.message;
import static de.his.core.base.invariants.ViolationCheck.supply;
import static de.his.core.base.invariants.ViolationCheck.supplyIgnoringArgument;
import static org.apache.commons.lang3.StringUtils.SPACE;

import java.io.File;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.apache.commons.lang.ObjectUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.Validate;
*/

/**
 * <p>Class which ensures method invariants for the arguments.</p>
 *
 * <p>If the invariant conditions are violated an {@code IllegalArgumentException} will be thrown.<p>
 *
 * @author mweyland
 * @version $Revision: 1.10 $
 */
public final class EnsureArgumentWohlAbJava5_mitImportStatic {

    private static final String ENSURE_ARGUMENT_IS_FALSE_FAILED = "EnsureArgument.isFalse() failed";
    private static final String ENSURE_ARGUMENT_IS_NULL_FAILED = "EnsureArgument.isNull() failed";
    private static final String ENSURE_ARGUMENT_IS_NULL_OR_EMPTY_FAILED = "EnsureArgument.isNullOrEmpty() failed";
    private static final String ENSURE_ARGUMENT_IS_TRUE_FAILED = "EnsureArgument.isTrue() failed";
    private static final String ENSURE_ARGUMENT_NOT_BLANK_FAILED = "EnsureArgument.notBlank() failed";
    private static final String ENSURE_ARGUMENT_NOT_EMPTY_FAILED = "EnsureArgument.notEmpty() failed";
    private static final String ENSURE_ARGUMENT_NOT_NULL_FAILED = "EnsureArgument.notNull() failed";
    private static final String ARGUMENT_IS_NULL = ", argument is null";
    private static final String CLASS_ARGUMENT_FOR_TESTING_RUNTIME_TYPE_MUST_NOT_BE_NULL = "class argument for testing runtime type must not be null";
    private static final String COLON = ": ";
    private static final String MUSS_GESETZT_SEIN = " muss gesetzt sein!";

    private EnsureArgumentWohlAbJava5_mitImportStatic() {
        // prevent instantiation
    }

    /**
     * Ensure that the argument is true,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param value    the object checked to be true
     * @throws IllegalArgumentException in case of violation
     */
    public static void isTrue(final boolean value) {
        if (!value) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_IS_TRUE_FAILED);
        }
    }

    /**
     * Ensure that the argument is true,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param value    the value checked to be true
     * @param message  the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     */
    public static void isTrue(final boolean value, final String message) {
        if (!value) {
            throw illegalArgumentException(message, ENSURE_ARGUMENT_IS_TRUE_FAILED);
        }
    }

    /**
     * Ensure that the argument is true,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param value            the value checked to be true
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @throws IllegalArgumentException in case of violation
     */
    public static void isTrue(final boolean value, final Supplier<String> messageSupplier) {
        if (!value) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_IS_TRUE_FAILED);
        }
    }

    /**
     * Ensure that the argument is true,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object    the object checked to be true
     * @throws IllegalArgumentException in case of violation
     */
    public static void isTrue(final Boolean object) {
        notNull(object, () -> ENSURE_ARGUMENT_IS_TRUE_FAILED + ARGUMENT_IS_NULL);
        if (!Boolean.TRUE.equals(object)) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_IS_TRUE_FAILED);
        }
    }

    /**
     * Ensure that the argument is true,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object    the object checked to be true
     * @param message   the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     */
    public static void isTrue(final Boolean object, final String message) {
        if (!Boolean.TRUE.equals(object)) {
            throw illegalArgumentException(message, ENSURE_ARGUMENT_IS_TRUE_FAILED);
        }
    }

    /**
     * Ensure that the argument is true,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object           the object checked to be true
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @throws IllegalArgumentException in case of violation
     */
    public static void isTrue(final Boolean object, final Supplier<String> messageSupplier) {
        if (!Boolean.TRUE.equals(object)) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_IS_TRUE_FAILED);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the test result is false and using a
     * custom message if the constraint has been violated.
     *
     * @param expression    the expression to be checked
     * @param message       the custom message to be used in case of a violation
     * @param value         the offending value
     */
    public static void isTrue(final boolean expression, final String message, final double value) {
        if (!expression) {
            throw new IllegalArgumentException(message(message, ENSURE_ARGUMENT_IS_TRUE_FAILED) + COLON + value);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the test result is false and using a
     * custom message if the constraint has been violated.
     *
     * @param expression       the expression to be checked
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @param value            the offending value
     */
    public static void isTrue(final boolean expression, final Supplier<String> messageSupplier, final double value) {
        if (!expression) {
            throw new IllegalArgumentException(message(messageSupplier, ENSURE_ARGUMENT_IS_TRUE_FAILED) + COLON + value);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the test result is false and using a
     * custom message if the constraint has been violated.
     *
     * @param expression    the expression to be checked
     * @param message       the custom message to be used in case of a violation
     * @param value         the offending value
     */
    public static void isTrue(final boolean expression, final String message, final long value) {
        if (!expression) {
            throw new IllegalArgumentException(message(message, ENSURE_ARGUMENT_IS_TRUE_FAILED) + COLON + value);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the test result is false and using a
     * custom message if the constraint has been violated.
     *
     * @param expression       the expression to be checked
     * @param messageSupplier  the custom suplier to be used to get the message in case of a violation
     * @param value            the offending value
     */
    public static void isTrue(final boolean expression, final Supplier<String> messageSupplier, final long value) {
        if (!expression) {
            throw new IllegalArgumentException(message(messageSupplier, ENSURE_ARGUMENT_IS_TRUE_FAILED) + COLON + value);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the test result is false and using a
     * custom message if the constraint has been violated.
     *
     * @param expression    the expression to be checked
     * @param message       the custom message to be used in case of a violation
     * @param value         the offending object
     */
    public static void isTrue(final boolean expression, final String message, final Object value) {
        if (!expression) {
            throw new IllegalArgumentException(message(message, ENSURE_ARGUMENT_IS_TRUE_FAILED) + COLON + value);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the test result is false and using a
     * custom message if the constraint has been violated.
     *
     * @param expression       the expression to be checked
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @param value            the offending object
     */
    public static void isTrue(final boolean expression, final Supplier<String> messageSupplier, final Object value) {
        if (!expression) {
            throw new IllegalArgumentException(message(messageSupplier, ENSURE_ARGUMENT_IS_TRUE_FAILED) + COLON + value);
        }
    }

    /**
     * Ensure that the argument is false,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param value    the value checked to be false
     * @throws IllegalArgumentException when {@code value != false}
     */
    public static void isFalse(final boolean value) {
        if (value) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_IS_FALSE_FAILED);
        }
    }

    /**
     * Ensure that the argument is false,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param value    the value checked to be false
     * @param message   the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     */
    public static void isFalse(final boolean value, final String message) {
        if (value) {
            throw illegalArgumentException(message, ENSURE_ARGUMENT_IS_FALSE_FAILED);
        }
    }

    /**
     * Ensure that the argument is false,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param value    the value checked to be false
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @throws IllegalArgumentException in case of violation
     */
    public static void isFalse(final boolean value, final Supplier<String> messageSupplier) {
        if (value) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_IS_FALSE_FAILED);
        }
    }

    /**
     * Ensure that the argument is False,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object    the object checked to be False
     * @throws IllegalArgumentException in case of violation
     */
    public static void isFalse(final Boolean object) {
        notNull(object, () -> ENSURE_ARGUMENT_IS_FALSE_FAILED + ARGUMENT_IS_NULL);
        if (!Boolean.FALSE.equals(object)) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_IS_FALSE_FAILED);
        }
    }

    /**
     * Ensure that the argument is False,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object    the object checked to be False
     * @param message   the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     */
    public static void isFalse(final Boolean object, final String message) {
        if (!Boolean.FALSE.equals(object)) {
            throw illegalArgumentException(message, ENSURE_ARGUMENT_IS_FALSE_FAILED);
        }
    }

    /**
     * Ensure that the argument is False,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object           the object checked to be False
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @throws IllegalArgumentException in case of violation
     */
    public static void isFalse(final Boolean object, final Supplier<String> messageSupplier) {
        if (!Boolean.FALSE.equals(object)) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_IS_FALSE_FAILED);
        }
    }

    /**
     * Ensure that the argument is an instance of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object      the object checked to be an instance of the given type
     * @param typeToCheck the class instance of the type that the object is checked to be an instance of
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of the expected type
     */
    public static void isOfType(final Object object, final Class<?> typeToCheck) {
        ofType(object, typeToCheck, true, (Supplier<String>)null, true);
    }

    /**
     * Ensure that the argument is an instance of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object      the object checked to be an instance of the given type
     * @param typeToCheck the class instance of the type that the object is checked to be an instance of
     * @param message     the custom message to be used in case of a violation
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of the expected type
     */
    public static void isOfType(final Object object, final Class<?> typeToCheck, final String message) {
        ofType(object, typeToCheck, true, supply(message), true);
    }

    /**
     * Ensure that the argument is an instance of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object           the object checked to be an instance of the given type
     * @param typeToCheck      the class instance of the type that the object is checked to be an instance of
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of the expected type
     */
    public static void isOfType(final Object object, final Class<?> typeToCheck, final Supplier<String> messageSupplier) {
        ofType(object, typeToCheck, true, messageSupplier, true);
    }

    /**
     * Ensure that the argument is an instance of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the object is checked to be an instance of
     *
     * @param object the object checked to be an instance of the given type
     *
     * @returns the object guaranteed to be an instance of the expected type, or {@code null} if the object is {@code null}
     *
     * @throws IllegalArgumentException if the object is not an instance of the expected type
     */
    public static <T> T ofType(final Object object) {
        return ofType(object, null, false, (Supplier<String>)null, true);
    }

    /**
     * Ensure that the argument is an instance of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the object is checked to be an instance of
     *
     * @param object      the object checked to be an instance of the given type
     * @param typeToCheck the class instance of the type that the object is checked to be an instance of
     *
     * @returns the object guaranteed to be an instance of the expected type, or {@code null} if the object is {@code null}
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of the expected type
     */
    public static <T> T ofType(final Object object, final Class<T> typeToCheck) {
        return ofType(object, typeToCheck, true, (Supplier<String>)null, true);
    }

    /**
     * Ensure that the argument is an instance of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the object is checked to be an instance of
     *
     * @param object      the object checked to be an instance of the given type
     * @param message     the custom message to be used in case of a violation
     *
     * @returns the object guaranteed to be an instance of the expected type, or {@code null} if the object is {@code null}
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of the expected type
     */
    public static <T> T ofType(final Object object, final String message) {
        return ofType(object, null, false, supply(message), true);
    }

    /**
     * Ensure that the argument is an instance of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the object is checked to be an instance of
     *
     * @param object      the object checked to be an instance of the given type
     * @param typeToCheck the class instance of the type that the object is checked to be an instance of
     * @param message     the custom message to be used in case of a violation
     *
     * @returns the object guaranteed to be an instance of the expected type, or {@code null} if the object is {@code null}
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of the expected type
     */
    public static <T> T ofType(final Object object, final Class<T> typeToCheck, final String message) {
        return ofType(object, typeToCheck, true, supply(message), true);
    }

    /**
     * Ensure that the argument is an instance of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the object is checked to be an instance of
     *
     * @param object          the object checked to be an instance of the given type
     * @param messageSupplier the custom supplier to be used to get the message in case of a violation
     *
     * @returns the object guaranteed to be an instance of the expected type, or {@code null} if the object is {@code null}
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of the expected type
     */
    public static <T> T ofType(final Object object, final Supplier<String> messageSupplier) {
        return ofType(object, null, false, messageSupplier, true);
    }

    /**
     * Ensure that the argument is an instance of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the object is checked to be an instance of
     *
     * @param object          the object checked to be an instance of the given type
     * @param typeToCheck     the class instance of the type that the object is checked to be an instance of
     * @param messageSupplier the custom supplier to be used to get the message in case of a violation
     *
     * @returns the object guaranteed to be an instance of the expected type, or {@code null} if the object is {@code null}
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of the expected type
     */
    public static <T> T ofType(final Object object, final Class<T> typeToCheck, final Supplier<String> messageSupplier) {
        return ofType(object, typeToCheck, true, messageSupplier, true);
    }

    /**
     * Ensure that the argument is <b>not</b> an instance of a given type,
     * throwing an {@linkplain IllegalArgumentException} if it does.
     *
     * @param object      the object checked to be <b>not</b> an instance of the given type
     * @param typeToCheck the class instance of the type that the object is checked to be <b>not</b> an instance of
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object <b>is</b> an instance of the given type
     */
    public static void notOfType(final Object object, final Class<?> typeToCheck) {
        ofType(object, typeToCheck, true, (Supplier<String>)null, false);
    }

    /**
     * Ensure that the argument is <b>not</b> an instance of a given type,
     * throwing an {@linkplain IllegalArgumentException} if it does.
     *
     * @param object      the object checked to be <b>not</b> an instance of the given type
     * @param typeToCheck the class instance of the type that the object is checked to be <b>not</b> an instance of
     * @param message     the custom message to be used in case of a violation
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object <b>is</b> an instance of the given type
     */
    public static void notOfType(final Object object, final Class<?> typeToCheck, final String message) {
        ofType(object, typeToCheck, true, supply(message), false);
    }

    /**
     * Ensure that the argument is <b>not</b> an instance of a given type,
     * throwing an {@linkplain IllegalArgumentException} if it does.
     *
     * @param object      the object checked to be <b>not</b> an instance of the given type
     * @param typeToCheck the class instance of the type that the object is checked to be <b>not</b> an instance of
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object <b>is</b> an instance of the given type
     */
    public static void notOfType(final Object object, final Class<?> typeToCheck, final Supplier<String> messageSupplier) {
        ofType(object, typeToCheck, true, messageSupplier, false);
    }

    /**
     * Depending on the given {@code assertInstance} flag this method ensures
     * that the argument <b>is</b> or is <b>not</b> an instance of expected type,
     * throwing an {@linkplain IllegalArgumentException} if the condition ist not met.
     *
     * @param <T> the type that the object is checked to be (or <b>not</b> to be) an instance of
     *
     * @param object          the object whose type is checked to the given type
     * @param typeToCheck     the class instance of the type that is checked to the object's type
     * @param nonNullType     wether to check the given type must be a non-{@code null} value
     * @param messageSupplier the custom supplier to be used to get the message in case of a violation
     * @param assertInstance  whether to check the given object is an instance of the expected type or not
     *
     * @returns the object guaranteed to be an instance of the expected type, or {@code null} if the object is
     *          {@code null} (or if the {@code assertInstance} flag is {@code false})
     *
     * @throws IllegalArgumentException if the type to check is {@code null} but it is expected to be non-null
     * @throws IllegalArgumentException if the condition for the object's type checking is not met
     */
    private static <T> T ofType(final Object object, 
                                final Class<T> typeToCheck, 
                                final boolean nonNullType,
                                final Supplier<String> messageSupplier,
                                final boolean assertInstance) {
        if (nonNullType) {
            EnsureArgument.notNull(typeToCheck, CLASS_ARGUMENT_FOR_TESTING_RUNTIME_TYPE_MUST_NOT_BE_NULL);
        }
        if (object == null) {
            return null;
        }
        T result = null;
        ClassCastException caughtClassCastException = null;
        
        try {
            @SuppressWarnings("unchecked")
            final T castedObject = (typeToCheck != null ? typeToCheck.cast(object) : (T)object);
            
            result = castedObject;
        }
        catch (final ClassCastException ex) {
            try {
                // letzter Versuch, ein eventuell vorliegendes Proxy-Objekt (z.B Spring-AOP, Mockito) aufzulösen
                result = getTargetObject(object, typeToCheck);
            }
            catch (final ClassCastException proxyCastEx) {
                // fall through
                caughtClassCastException = proxyCastEx;
            }
            catch (final Throwable proxyEx) {
                throw illegalArgumentException(messageSupplier, () -> {
                    if (typeToCheck != null) {
                        return "EnsureArgument.ofType() failed: object is " + getTargetClass(object).getSimpleName() + " (expected " + typeToCheck.getSimpleName() + ")";
                    } else {
                        return "EnsureArgument.ofType() failed: object is " + getTargetClass(object).getSimpleName();
                    }
                }, proxyEx);
            }
        }

        // es wird erwartet, dass das Objekt einen bestimmten Typ hat, aber der Cast ist fehlgeschlagen
        if (assertInstance && result == null) {
            throw illegalArgumentException(messageSupplier, () -> {
                if (typeToCheck != null) {
                    return "EnsureArgument.ofType() failed: object is " + getTargetClass(object).getSimpleName() + " (expected " + typeToCheck.getSimpleName() + ")";
                } else {
                    return "EnsureArgument.ofType() failed: object is " + getTargetClass(object).getSimpleName();                        
                }
            }, caughtClassCastException);
        }
        // es wird erwartet, dass das Objekt den bestimmten Typ *nicht* hat, aber der Cast war erfolgreich
        else if (!assertInstance && result != null) {
            throw illegalArgumentException(messageSupplier, () -> {
                if (typeToCheck != null) {
                    return "EnsureArgument.ofType() failed: object is not expected to be an instance of " + typeToCheck.getSimpleName() + "; object is " + getTargetClass(object).getSimpleName();
                } else {            
                    return "EnsureArgument.ofType() failed: object is not expected to be an instance of requested type; object is " + getTargetClass(object).getSimpleName();
                }
            });
        }
        
        return result;
    }

    /**
     * Ensure that the argument is a class that is a subclass of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz       the class checked to be a subclass of the given type
     * @param typeToCheck the class instance of the type that the class object is checked to be a subclass of
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not a subclass of the expected type
     */
    public static void isOfType(final Class<?> clazz, final Class<?> typeToCheck) {
        ofType(clazz, typeToCheck, true, (Supplier<String>)null, true);
    }

    /**
     * Ensure that the argument is a class that is a subclass of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz       the class checked to be a subclass of the given type
     * @param typeToCheck the class instance of the type that the class object is checked to be a subclass of
     * @param message     the custom message to be used in case of a violation
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not a subclass of the expected type
     */
    public static void isOfType(final Class<?> clazz, final Class<?> typeToCheck, final String message) {
        ofType(clazz, typeToCheck, true, supply(message), true);
    }

    /**
     * Ensure that the argument is a class that is a subclass of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz            the class checked to be a subclass of the given type
     * @param typeToCheck      the class instance of the type that the class object is checked to be a subclass of
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not a subclass of the expected type
     */
    public static void isOfType(final Class<?> clazz, final Class<?> typeToCheck, final Supplier<String> messageSupplier) {
        ofType(clazz, typeToCheck, true, messageSupplier, true);
    }

    /**
     * Ensure that the argument is a class that is <b>not</b> a subclass of given type,
     * throwing an {@linkplain IllegalArgumentException} if it is.
     *
     * @param clazz       the class checked to be <b>not</b> a subclass of the given type
     * @param typeToCheck the class instance of the type that the class object is checked to be <b>not</b> a subclass of
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class <b>is<b> a subclass of the given type
     */
    public static void notOfType(final Class<?> clazz, final Class<?> typeToCheck) {
        ofType(clazz, typeToCheck, true, (Supplier<String>)null, false);
    }

    /**
     * Ensure that the argument is a class that is <b>not</b> a subclass of given type,
     * throwing an {@linkplain IllegalArgumentException} if it is.
     *
     * @param clazz       the class checked to be <b>not</b> a subclass of the given type
     * @param typeToCheck the class instance of the type that the class object is checked to be <b>not</b> a subclass of
     * @param message     the custom message to be used in case of a violation
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class <b>is<b> a subclass of the given type
     */
    public static void notOfType(final Class<?> clazz, final Class<?> typeToCheck, final String message) {
        ofType(clazz, typeToCheck, true, supply(message), false);
    }

    /**
     * Ensure that the argument is a class that is <b>not</b> a subclass of given type,
     * throwing an {@linkplain IllegalArgumentException} if it is.
     *
     * @param clazz       the class checked to be <b>not</b> a subclass of the given type
     * @param typeToCheck the class instance of the type that the class object is checked to be <b>not</b> a subclass of
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class <b>is<b> a subclass of the given type
     */
    public static void notOfType(final Class<?> clazz, final Class<?> typeToCheck, final Supplier<String> messageSupplier) {
        ofType(clazz, typeToCheck, true, messageSupplier, false);
    }
    
    /**
     * Ensure that the argument is a class that is a subclass of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the class is checked to be a subclass of
     *
     * @param clazz the class checked to be a subclass of the given type
     *
     * @returns the class guaranteed to be a subclass of the expected type, or {@code null} if the class is {@code null}
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the class is not a subclass of the expected type
     */
    public static <T> Class<T> ofType(final Class<?> clazz) {
        return ofType(clazz, null, false, (Supplier<String>)null, true);
    }

    /**
     * Ensure that the argument is a class that is a subclass of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the class is checked to be a subclass of
     *
     * @param clazz       the class checked to be a subclass of the given type
     * @param typeToCheck the class instance of the type that the class object is checked to be a subclass of
     *
     * @returns the class guaranteed to be a subclass of the expected type, or {@code null} if the class is {@code null}
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not a subclass of the expected type
     */
    public static <T> Class<T> ofType(final Class<?> clazz, final Class<T> typeToCheck) {
        return ofType(clazz, typeToCheck, true, (Supplier<String>)null, true);
    }

    /**
     * Ensure that the argument is a class that is a subclass of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the class is checked to be a subclass of
     *
     * @param clazz       the class checked to be a subclass of the given type
     * @param message     the custom message to be used in case of a violation
     *
     * @returns the class guaranteed to be a subclass of the expected type, or {@code null} if the class is {@code null}
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the class is not a subclass of the expected type
     */
    public static <T> Class<T> ofType(final Class<?> clazz, final String message) {
        return ofType(clazz, null, false, supply(message), true);
    }

    /**
     * Ensure that the argument is a class that is a subclass of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the class is checked to be a subclass of
     *
     * @param clazz       the class checked to be a subclass of the given type
     * @param typeToCheck the class instance of the type that the class object is checked to be a subclass of
     * @param message     the custom message to be used in case of a violation
     *
     * @returns the class guaranteed to be a subclass of the expected type, or {@code null} if the class is {@code null}
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not a subclass of the expected type
     */
    public static <T> Class<T> ofType(final Class<?> clazz, final Class<T> typeToCheck, final String message) {
        return ofType(clazz, typeToCheck, true, supply(message), true);
    }

    /**
     * Ensure that the argument is a class that is a subclass of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the class is checked to be a subclass of
     *
     * @param clazz            the class checked to be a subclass of the given type
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     *
     * @returns the class guaranteed to be a subclass of the expected type, or {@code null} if the class is {@code null}
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the class is not a subclass of the expected type
     */
    public static <T> Class<T> ofType(final Class<?> clazz, final Supplier<String> messageSupplier) {
        return ofType(clazz, null, false, messageSupplier, true);
    }

    /**
     * Ensure that the argument is a class that is a subclass of expected type,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param <T> the type that the class is checked to be a subclass of
     *
     * @param clazz            the class checked to be a subclass of the given type
     * @param typeToCheck      the class instance of the type that the class object is checked to be a subclass of
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     *
     * @returns the class guaranteed to be a subclass of the expected type, or {@code null} if the class is {@code null}
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not a subclass of the expected type
     */
    public static <T> Class<T> ofType(final Class<?> clazz, final Class<T> typeToCheck, final Supplier<String> messageSupplier) {
        return ofType(clazz, typeToCheck, true, messageSupplier, true);
    }

    /**
     * Depending on the given {@code assertAssignability} flag this method ensures that
     * the argument is a class that <b>is</b> or is <b>not</b> a subclass of expected type,
     * throwing an {@linkplain IllegalArgumentException} if the condition ist not met.
     *
     * @param <T> the type that the class is checked to be (or <b>not</b> to be) a subclass of
     *
     * @param clazz               the class to check to the given type
     * @param typeToCheck         the class instance of the type that is checked against the {@code clazz} argument
     * @param nonNullType         wether to check the given type must be a non-{@code null} value
     * @param messageSupplier     the custom supplier to be used to get the message in case of a violation
     * @param assertAssignability whether to check the given class is a subclass of the expected type or not
     *
     * @returns the class guaranteed to be a subclass of the expected type, or {@code null} if the class is {@code null}
     *          (or if the {@code assertAssignability} flag is {@code false})
     *
     * @throws IllegalArgumentException if the class to check is {@code null} but it is expected to be a subclass of the
     *                                  non-{@code null} type to check
     * @throws IllegalArgumentException if the type to check is {@code null} but it is expected to be non-{@code null}
     * @throws IllegalArgumentException if the condition for the class type checking is not met
     */
    private static <T> Class<T> ofType(final Class<?> clazz, 
                                       final Class<T> typeToCheck, 
                                       final boolean nonNullType,
                                       final Supplier<String> messageSupplier,
                                       final boolean assertAssignability) {
        if (nonNullType) {
            EnsureArgument.notNull(typeToCheck, CLASS_ARGUMENT_FOR_TESTING_RUNTIME_TYPE_MUST_NOT_BE_NULL);
        }
        if (typeToCheck != null || assertAssignability) {
            EnsureArgument.notNull(clazz, CLASS_ARGUMENT_FOR_TESTING_RUNTIME_TYPE_MUST_NOT_BE_NULL);
        }
        if (clazz == null) {
            return null;
        }
        Class<T> result = null;
        ClassCastException caughtClassCastException = null;
     
        try {
            @SuppressWarnings("unchecked")
            final Class<T> castedClass = (Class<T>)(typeToCheck != null ? clazz.asSubclass(typeToCheck) : clazz);
            
            result = castedClass;
        }
        catch (final ClassCastException ex) {
            // fall through
            caughtClassCastException = ex;
        }

        // es wird erwartet, dass die Klasse einen bestimmten Typ hat, aber der Cast ist fehlgeschlagen
        if (assertAssignability && result == null) {
            throw illegalArgumentException(messageSupplier, () -> {
                if (typeToCheck != null) {
                    return "EnsureArgument.ofType() failed: class is " + clazz.getSimpleName() + " (expected " + typeToCheck.getSimpleName() + ")";
                } else {
                    return "EnsureArgument.ofType() failed: class is " + clazz.getSimpleName();                        
                }
            }, caughtClassCastException);
        }
        // es wird erwartet, dass die Klasse den bestimmten Typ *nicht* hat, aber der Cast war erfolgreich
        else if (!assertAssignability && result != null) {
            throw illegalArgumentException(messageSupplier, () -> {
                if (typeToCheck != null) {
                    return "EnsureArgument.ofType() failed: class is not expected to be a subclass of " + typeToCheck.getSimpleName() + "; class is " + clazz.getSimpleName();
                } else {            
                    return "EnsureArgument.ofType() failed: class is not expected to be a subclass of requested type; class is " + clazz.getSimpleName();
                }
            });
        }
        
        return result;
    }

    /**
     * Ensure that the argument is an instance of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object            the object checked to be an instance of the given type
     * @param typeToCheck       the class instance of the type that is checked to the object's type
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the object is checked to be an instance of
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of all of the expected types
     */
    public static void isOfTypes(final Object object, final Class<?> typeToCheck, final Class<?>... additionalInterfacesToCheck) {
        ofTypes(object, typeToCheck, additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is an instance of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object            the object checked to be an instance of the given type
     * @param typeToCheck       the class instance of the type that is checked to the object's type
     * @param message           the custom message to be used in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the object is checked to be an instance of
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of all of the expected types
     */
    public static void isOfTypes(final Object object, final Class<?> typeToCheck, final String message, final Class<?>... additionalInterfacesToCheck) {
        ofTypes(object, typeToCheck, message, additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is an instance of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object            the object checked to be an instance of the given type
     * @param typeToCheck       the class instance of the type that is checked to the object's type
     * @param messageSupplier   the custom supplier to be used to get the message in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the object is checked to be an instance of
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of all of the expected types
     */
    public static void isOfTypes(final Object object, final Class<?> typeToCheck, final Supplier<String> messageSupplier, final Class<?>... additionalInterfacesToCheck) {
        ofTypes(object, typeToCheck, messageSupplier, additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is an instance of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object            the object checked to be an instance of the given type
     * @param typeToCheck       the class instance of the type that is checked to the object's type
     * @param messageSupplier   the custom supplier to be used to get the message in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the object is checked to be an instance of
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of all of the expected types
     */
    public static void isOfTypes(final Object object, final Class<?> typeToCheck, final Function<Class<?>,String> messageSupplier, final Class<?>... additionalInterfacesToCheck) {
        ofTypes(object, typeToCheck, messageSupplier, additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is an instance of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object            the object checked to be an instance of the given type
     * @param typeToCheck       the class instance of the type that is checked to the object's type
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the object is checked to be an instance of
     *
     * @returns the object guaranteed to be an instance of all of the expected interfaces, or {@code null} if the object is {@code null}
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of all of the expected types
     */
    public static <T> T ofTypes(final Object object, final Class<T> typeToCheck, final Class<?>... additionalInterfacesToCheck) {
        final Function<Class<?>, String> messageSupplier = (interfaceToCheck) -> "EnsureArgument.ofTypes() failed: object is " + getTargetClass(object).getSimpleName() + " (expected "
                        + interfaceToCheck.getSimpleName() + ")";
        
        return ofTypes(object, typeToCheck, messageSupplier, additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is an instance of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object            the object checked to be an instance of the given type
     * @param typeToCheck       the class instance of the type that is checked to the object's type
     * @param message           the custom message to be used in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the object is checked to be an instance of
     *
     * @returns the object guaranteed to be an instance of all of the expected interfaces, or {@code null} if the object is {@code null}
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of all of the expected types
     */
    public static <T> T ofTypes(final Object object, final Class<T> typeToCheck, final String message, final Class<?>... additionalInterfacesToCheck) {
        return ofTypes(object, typeToCheck, supplyIgnoringArgument(message), additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is an instance of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object            the object checked to be an instance of the given type
     * @param typeToCheck       the class instance of the type that is checked to the object's type
     * @param messageSupplier   the custom supplier to be used to get the message in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the object is checked to be an instance of
     *
     * @returns the object guaranteed to be an instance of all of the expected interfaces, or {@code null} if the object is {@code null}
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of all of the expected types
     */
    public static <T> T ofTypes(final Object object, final Class<T> typeToCheck, final Supplier<String> messageSupplier, final Class<?>... additionalInterfacesToCheck) {
        return ofTypes(object, typeToCheck, supplyIgnoringArgument(messageSupplier), additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is an instance of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param object            the object checked to be an instance of the given type
     * @param typeToCheck       the class instance of the type that is checked to the object's type
     * @param messageSupplier   the custom supplier to be used to get the message in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the object is checked to be an instance of
     *
     * @returns the object guaranteed to be an instance of all of the expected interfaces, or {@code null} if the object is {@code null}
     *
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the object is not an instance of all of the expected types
     */
    public static <T> T ofTypes(final Object object, final Class<T> typeToCheck, final Function<Class<?>, String> messageSupplier, final Class<?>... additionalInterfacesToCheck) {
        final Supplier<String> _messageSupplier = () -> {
            return "EnsureArgument.ofTypes() failed: object is " + getTargetClass(object).getSimpleName() + " (expected " + typeToCheck.getSimpleName() + ")";
        };
        
        final T result = ofType(object, typeToCheck, true, _messageSupplier, true);
        
        if (object != null && additionalInterfacesToCheck != null && additionalInterfacesToCheck.length > 0) {
            for (final Class<?> additionalInterfaceToCheck : additionalInterfacesToCheck) {
                if (additionalInterfaceToCheck != null && !additionalInterfaceToCheck.isInstance(object)) {
                    String message = (messageSupplier == null ? null : StringUtils.stripToNull(messageSupplier.apply(additionalInterfaceToCheck)));
                    if (message == null) {
                        final String namesOfExpectedTypes = Arrays.stream(additionalInterfacesToCheck).map(t -> t.getSimpleName()).collect(Collectors.joining(" & "));

                        message = "EnsureArgument.ofTypes() failed: object is " + getTargetClass(object).getSimpleName() + " (expected " + namesOfExpectedTypes + ")";
                    }
                    throw new IllegalArgumentException(message);
                }
            }
        }
        return result;
    }

    /**
     * Ensure that the argument is a class that is an implementor of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz             the class checked to be a subclass of the given type
     * @param typeToCheck       the class instance of the type that the class object is checked to be a subclass of
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the class is checked to be an implementor of
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not an implementor of the expected types
     */
    public static void isOfTypes(final Class<?> clazz, final Class<?> typeToCheck, final Class<?>... additionalInterfacesToCheck) {
        ofTypes(clazz, typeToCheck, additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is a class that is an implementor of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz             the class checked to be a subclass of the given type
     * @param typeToCheck       the class instance of the type that the class object is checked to be a subclass of
     * @param message           the custom message to be used in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the class is checked to be an implementor of
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not an implementor of the expected types
     */
    public static void isOfTypes(final Class<?> clazz, final Class<?> typeToCheck, final String message, final Class<?>... additionalInterfacesToCheck) {
        ofTypes(clazz, typeToCheck, message, additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is a class that is an implementor of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz             the class checked to be a subclass of the given type
     * @param typeToCheck       the class instance of the type that the class object is checked to be a subclass of
     * @param messageSupplier   the custom supplier to be used to get the message in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the class is checked to be an implementor of
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not an implementor of the expected types
     */
    public static void isOfTypes(final Class<?> clazz, final Class<?> typeToCheck, final Supplier<String> messageSupplier, final Class<?>... additionalInterfacesToCheck) {
        ofTypes(clazz, typeToCheck, messageSupplier, additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is a class that is an implementor of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz             the class checked to be a subclass of the given type
     * @param typeToCheck       the class instance of the type that the class object is checked to be a subclass of
     * @param messageSupplier   the custom supplier to be used to get the message in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the class is checked to be an implementor of
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not an implementor of the expected types
     */
    public static void isOfTypes(final Class<?> clazz, final Class<?> typeToCheck, final Function<Class<?>,String> messageSupplier, final Class<?>... additionalInterfacesToCheck) {
        ofTypes(clazz, typeToCheck, messageSupplier, additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is a class that is an implementor of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz             the class checked to be a subclass of the given type
     * @param typeToCheck       the class instance of the type that the class object is checked to be a subclass of
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the class is checked to be an implementor of
     *
     * @returns the class guaranteed to be an implementor of the expected interfaces, or {@code null} if the class is {@code null}
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not an implementor of the expected types
     */
    public static <T> Class<T> ofTypes(final Class<?> clazz, final Class<T> typeToCheck, final Class<?>... additionalInterfacesToCheck) {
        final Function<Class<?>, String> messageSupplier = (interfaceToCheck) -> "EnsureArgument.ofTypes() failed: class is " + clazz.getSimpleName() + " (expected "
                        + interfaceToCheck.getSimpleName() + ")";
        
        return ofTypes(clazz, typeToCheck, messageSupplier, additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is a class that is an implementor of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz             the class checked to be a subclass of the given type
     * @param typeToCheck       the class instance of the type that the class object is checked to be a subclass of
     * @param message           the custom message to be used in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the class is checked to be an implementor of
     *
     * @returns the class guaranteed to be an implementor of the expected interfaces, or {@code null} if the class is {@code null}
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not an implementor of the expected types
     */
    public static <T> Class<T> ofTypes(final Class<?> clazz, final Class<T> typeToCheck, final String message, final Class<?>... additionalInterfacesToCheck) {
        return ofTypes(clazz, typeToCheck, supplyIgnoringArgument(message), additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is a class that is an implementor of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz             the class checked to be a subclass of the given type
     * @param typeToCheck       the class instance of the type that the class object is checked to be a subclass of
     * @param messageSupplier   the custom supplier to be used to get the message in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the class is checked to be an implementor of
     *
     * @returns the class guaranteed to be an implementor of the expected interfaces, or {@code null} if the class is {@code null}
     *
     * @throws IllegalArgumentException if the class to check is {@code null}
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not an implementor of the expected types
     */
    public static <T> Class<T> ofTypes(final Class<?> clazz, final Class<T> typeToCheck, final Supplier<String> messageSupplier, final Class<?>... additionalInterfacesToCheck) {
        return ofTypes(clazz, typeToCheck, supplyIgnoringArgument(messageSupplier), additionalInterfacesToCheck);
    }

    /**
     * Ensure that the argument is a class that is an implementor of expected interfaces,
     * throwing an {@linkplain IllegalArgumentException} if not.
     *
     * @param clazz             the class checked to be a subclass of the given type
     * @param typeToCheck       the class instance of the type that the class object is checked to be a subclass of
     * @param messageSupplier   the custom supplier to be used to get the message in case of a violation
     * @param additionalInterfacesToCheck the (optional) additional class instances of the interfaces that the class is checked to be an implementor of
     *
     * @returns the class guaranteed to be an implementor of the expected interfaces, or {@code null} if the class is {@code null}
     *
     * @throws IllegalArgumentException if the class to check is {@code null} but it is expected to be an implementor of
     *                                  the non-{@code null} class instances of the interfaces to check
     * @throws IllegalArgumentException if the type to check is {@code null}
     * @throws IllegalArgumentException if the class is not an implementor of the expected types
     */
    public static <T> Class<T> ofTypes(final Class<?> clazz, final Class<T> typeToCheck, final Function<Class<?>, String> messageSupplier, final Class<?>... additionalInterfacesToCheck) {
        final Supplier<String> _messageSupplier = () -> {
            return "EnsureArgument.ofTypes() failed: class is " + clazz.getSimpleName() + " (expected " + typeToCheck.getSimpleName() + ")";
        };
        
        final Class<T> result = ofType(clazz, typeToCheck, true, _messageSupplier, true);
        
        if (clazz != null && additionalInterfacesToCheck != null && additionalInterfacesToCheck.length > 0) {
            for (final Class<?> additionalInterfaceToCheck : additionalInterfacesToCheck) {
                if (additionalInterfaceToCheck != null && !additionalInterfaceToCheck.isAssignableFrom(clazz)) {
                    String message = (messageSupplier == null ? null : StringUtils.stripToNull(messageSupplier.apply(additionalInterfaceToCheck)));
                    if (message == null) {
                        final String namesOfExpectedTypes = Arrays.stream(additionalInterfacesToCheck).map(t -> t.getSimpleName()).collect(Collectors.joining(" & "));

                        message = "EnsureArgument.ofTypes() failed: class is " + clazz.getSimpleName() + " (expected " + namesOfExpectedTypes + ")";
                    }
                    throw new IllegalArgumentException(message);
                }
            }
        }
        return result;
    }

    /**
     * Ensure that the argument is not null,
     * returning the non-null object if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object    the object checked to be non-null
     * @throws IllegalArgumentException in case of violation
     * @returns the object guaranteed to be non-null
     */
    public static <T> T notNull(final T object) {
        if (object == null) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_NOT_NULL_FAILED);
        }
        return object;
    }

    /**
     * Ensure that the argument is not null,
     * returning the non-null object if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object    the object checked to be non-null
     * @param message   the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @returns the object guaranteed to be non-null
     */
    public static <T> T notNull(final T object, String message) {
        if (object == null) {
            throw illegalArgumentException(message, ENSURE_ARGUMENT_NOT_NULL_FAILED);
        }
        return object;
    }

    /**
     * Ensure that the argument is not null,
     * returning the non-null object if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object           the object checked to be non-null
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @returns the object guaranteed to be non-null
     */
    public static <T> T notNull(final T object, Supplier<String> messageSupplier) {
        if (object == null) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_NOT_NULL_FAILED);
        }
        return object;
    }

    /**
     * Ensure that the argument is not null,
     * returning the non-null object if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object            the object checked to be non-null
     * @param checkedValue      the name of the checked value to be used in case of a violation
     * @param additionalMessage the optional additional hint to avoid the detected violation
     * @throws IllegalArgumentException in case of violation
     * @returns the object guaranteed to be non-null
     */
    public static <T> T notNull(final T object, String checkedValue, String additionalMessage) {
        return notNull(object, checkedValue, supply(additionalMessage));
    }

    /**
     * Ensure that the argument is not null,
     * returning the non-null object if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object                    the object checked to be non-null
     * @param checkedValue              the name of the checked value to be used in case of a violation
     * @param additionalMessageSupplier the optional supplier of an additional hint to avoid the detected violation
     * @throws IllegalArgumentException in case of violation
     * @returns the object guaranteed to be non-null
     */
    public static <T> T notNull(final T object, String checkedValue, Supplier<String> additionalMessageSupplier) {
        if (object == null) {
            String message = checkedValue + MUSS_GESETZT_SEIN;
            final String additionalMessage = message(additionalMessageSupplier);
            
            if (additionalMessage != null) {
                message += SPACE + additionalMessage;
            }
            throw new IllegalArgumentException(message);
        }
        return object;
    }

    /**
     * Ensure that the argument is null,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object    the object checked to be null
     * @throws IllegalArgumentException in case of violation
     */
    public static void isNull(final Object object) {
        if (object != null) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_IS_NULL_FAILED);
        }
    }

    /**
     * Ensure that the argument is null,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object    the object checked to be non-null
     * @param message   the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     */
    public static void isNull(final Object object, final String message) {
        if (object != null) {
            throw illegalArgumentException(message);
        }
    }

    /**
     * Ensure that the argument is null,
     * throwing {@code IllegalArgumentException} if not
     *
     * @param object           the object checked to be non-null
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @throws IllegalArgumentException in case of violation
     */
    public static void isNull(final Object object, final Supplier<String> messageSupplier) {
        if (object != null) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_IS_NULL_FAILED);
        }
    }

    /**
     * Ensure that the string is not empty,
     * returning the non-empty string if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param string    the string checked to be non-empty
     * @throws IllegalArgumentException in case of violation
     * @return the string guaranteed to be non-empty
     */
    public static String notEmpty(String string) {
        notNull(string, () -> ENSURE_ARGUMENT_NOT_EMPTY_FAILED + ARGUMENT_IS_NULL);
        if (string.isEmpty()) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_NOT_EMPTY_FAILED);
        }
        return string;
    }

    /**
     * Ensure that the string is not empty,
     * returning the non-empty string if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param string    the string checked to be non-empty
     * @param message   the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @return the string guaranteed to be non-empty
     */
    public static String notEmpty(String string, String message) {
        return notEmpty(string, supply(message));
    }

    /**
     * Ensure that the string is not empty,
     * returning the non-empty string if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param string           the string checked to be non-empty
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @return the string guaranteed to be non-empty
     */
    public static String notEmpty(String string, Supplier<String> messageSupplier) {
        notNull(string, messageSupplier);
        if (string.isEmpty()) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_NOT_EMPTY_FAILED);
        }
        return string;
    }

    /**
     * Ensure that the string is not blank,
     * returning the non-blank string if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param string    the string checked to be non-blank
     * @throws IllegalArgumentException in case of violation
     * @return the string guaranteed to be non-empty
     */
    public static String notBlank(String string) {
        notNull(string, () -> ENSURE_ARGUMENT_NOT_BLANK_FAILED + ARGUMENT_IS_NULL);
        if (StringUtils.isBlank(string)) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_NOT_BLANK_FAILED);
        }
        return string;
    }

    /**
     * Ensure that the string is not blank,
     * returning the non-blank string if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param string    the string checked to be non-blank
     * @param message   the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @return the string guaranteed to be non-empty
     */
    public static String notBlank(String string, String message) {
        return notBlank(string, supply(message));
    }

    /**
     * Ensure that the string is not blank,
     * returning the non-blank string if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param string    the string checked to be non-blank
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @return the string guaranteed to be non-empty
     */
    public static String notBlank(String string, Supplier<String> messageSupplier) {
        notNull(string, messageSupplier);
        if (StringUtils.isBlank(string)) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_NOT_BLANK_FAILED);
        }
        return string;
    }

    /**
     * Ensure that the collection is not empty,
     * returning the non-empty collection if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param collection the collection checked to be non-empty
     * @throws IllegalArgumentException in case of violation
     * @return the collection guaranteed to be non-empty
     */
    public static <T extends Collection<?>> T notEmpty(T collection) {
        notNull(collection, () -> ENSURE_ARGUMENT_NOT_EMPTY_FAILED + ARGUMENT_IS_NULL);
        if (collection.isEmpty()) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_NOT_EMPTY_FAILED);
        }
        return collection;
    }

    /**
     * Ensure that the collection is not empty,
     * returning the non-empty collection if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param collection the collection checked to be non-empty
     * @param message    the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @return the collection guaranteed to be non-empty
     */
    public static <T extends Collection<?>> T notEmpty(T collection, String message) {
        return notEmpty(collection, supply(message));
    }

    /**
     * Ensure that the collection is not empty,
     * returning the non-empty collection if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param collection the collection checked to be non-empty
     * @param messageSupplier  the custom supplier to be used to getthe message in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @return the collection guaranteed to be non-empty
     */
    public static <T extends Collection<?>> T notEmpty(T collection, Supplier<String> messageSupplier) {
        notNull(collection, messageSupplier);
        if (collection.isEmpty()) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_NOT_EMPTY_FAILED);
        }
        return collection;
    }

    /**
     * Ensure that the map is not empty,
     * returning the non-empty map if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param map the map checked to be non-empty
     * @throws IllegalArgumentException in case of violation
     * @return the map guaranteed to be non-empty
     */
    public static <T extends Map<?, ?>> T notEmpty(T map) {
        notNull(map, () -> ENSURE_ARGUMENT_NOT_EMPTY_FAILED + ARGUMENT_IS_NULL);
        if (map.isEmpty()) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_NOT_EMPTY_FAILED);
        }
        return map;
    }

    /**
     * Ensure that the map is not empty,
     * returning the non-empty map if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param map the map checked to be non-empty
     * @param message    the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @return the map guaranteed to be non-empty
     */
    public static <T extends Map<?, ?>> T notEmpty(T map, String message) {
        return notEmpty(map, supply(message));
    }

    /**
     * Ensure that the map is not empty,
     * returning the non-empty map if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param map              the map checked to be non-empty
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @return the map guaranteed to be non-empty
     */
    public static <T extends Map<?, ?>> T notEmpty(T map, Supplier<String> messageSupplier) {
        notNull(map, messageSupplier);
        if (map.isEmpty()) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_NOT_EMPTY_FAILED);
        }
        return map;
    }

    /**
     * Ensure that the array is not empty,
     * returning the non-empty array if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param array the array checked to be non-empty
     * @throws IllegalArgumentException in case of violation
     * @return the array guaranteed to be non-empty
     */

    public static <T> T[] notEmpty(T[] array) {
        notNull(array, () -> ENSURE_ARGUMENT_NOT_EMPTY_FAILED + ARGUMENT_IS_NULL);
        if (array.length == 0) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_NOT_EMPTY_FAILED);
        }
        return array;
    }

    /**
     * Ensure that the array is not empty,
     * returning the non-empty array if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param array the array checked to be non-empty
     * @param message    the custom message to be used in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @return the array guaranteed to be non-empty
     */
    public static <T> T[] notEmpty(T[] array, String message) {
        return notEmpty(array, supply(message));
    }

    /**
     * Ensure that the array is not empty,
     * returning the non-empty array if so, and
     * throwing {@code IllegalArgumentException} if not
     *
     * @param array            the array checked to be non-empty
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     * @throws IllegalArgumentException in case of violation
     * @return the array guaranteed to be non-empty
     */
    public static <T> T[] notEmpty(T[] array, Supplier<String> messageSupplier) {
        notNull(array, messageSupplier);
        if (array.length == 0) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_NOT_EMPTY_FAILED);
        }
        return array;
    }

    /**
     * Ensure that a given collection is {@code null} or empty, and
     * throwing an {@link IllegalArgumentException} if not.
     *
     * @param collection the collection checked to be {@code null} or empty
     *
     * @throws IllegalArgumentException if the given collection contains any element
     */
    public static void isNullOrEmpty(final Collection<?> collection) {
        if (collection != null && !collection.isEmpty()) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_IS_NULL_OR_EMPTY_FAILED);
        }
    }

    /**
     * Ensure that a given collection is {@code null} or empty, and
     * throwing an {@link IllegalArgumentException} if not.
     *
     * @param collection the collection checked to be {@code null} or empty
     * @param message    the custom message to be used in case of a violation
     *
     * @throws IllegalArgumentException if the given collection contains any element
     */
    public static void isNullOrEmpty(final Collection<?> collection, final String message) {
        if (collection != null && !collection.isEmpty()) {
            throw illegalArgumentException(message, ENSURE_ARGUMENT_IS_NULL_OR_EMPTY_FAILED);
        }
    }

    /**
     * Ensure that a given collection is {@code null} or empty, and
     * throwing an {@link IllegalArgumentException} if not.
     *
     * @param collection the collection checked to be {@code null} or empty
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     *
     * @throws IllegalArgumentException if the given collection contains any element
     */
    public static void isNullOrEmpty(final Collection<?> collection, final Supplier<String> messageSupplier) {
        if (collection != null && !collection.isEmpty()) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_IS_NULL_OR_EMPTY_FAILED);
        }
    }

    /**
     * Ensure that a given map is {@code null} or empty, and
     * throwing an {@link IllegalArgumentException} if not.
     *
     * @param map the map checked to be {@code null} or empty
     *
     * @throws IllegalArgumentException if the given map contains any element
     */
    public static void isNullOrEmpty(final Map<?, ?> map) {
        if (map != null && !map.isEmpty()) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_IS_NULL_OR_EMPTY_FAILED);
        }
    }

    /**
     * Ensure that a given map is {@code null} or empty, and
     * throwing an {@link IllegalArgumentException} if not.
     *
     * @param map     the map checked to be {@code null} or empty
     * @param message the custom message to be used in case of a violation
     *
     * @throws IllegalArgumentException if the given map contains any element
     */
    public static void isNullOrEmpty(final Map<?, ?> map, final String message) {
        if (map != null && !map.isEmpty()) {
            throw illegalArgumentException(message, ENSURE_ARGUMENT_IS_NULL_OR_EMPTY_FAILED);
        }
    }

    /**
     * Ensure that a given map is {@code null} or empty, and
     * throwing an {@link IllegalArgumentException} if not.
     *
     * @param map              the map checked to be {@code null} or empty
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     *
     * @throws IllegalArgumentException if the given map contains any element
     */
    public static void isNullOrEmpty(final Map<?, ?> map, final Supplier<String> messageSupplier) {
        if (map != null && !map.isEmpty()) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_IS_NULL_OR_EMPTY_FAILED);
        }
    }

    /**
     * Ensure that a given array is {@code null} or empty, and
     * throwing an {@link IllegalArgumentException} if not.
     *
     * @param array the array checked to be {@code null} or empty
     *
     * @throws IllegalArgumentException if the given array contains any element
     */
    public static void isNullOrEmpty(final Object[] array) {
        if (array != null && array.length > 0) {
            throw new IllegalArgumentException(ENSURE_ARGUMENT_IS_NULL_OR_EMPTY_FAILED);
        }
    }

    /**
     * Ensure that a given array is {@code null} or empty, and
     * throwing an {@link IllegalArgumentException} if not.
     *
     * @param array   the array checked to be {@code null} or empty
     * @param message the custom message to be used in case of a violation
     *
     * @throws IllegalArgumentException if the given array contains any element
     */
    public static void isNullOrEmpty(final Object[] array, final String message) {
        if (array != null && array.length > 0) {
            throw illegalArgumentException(message, ENSURE_ARGUMENT_IS_NULL_OR_EMPTY_FAILED);
        }
    }

    /**
     * Ensure that a given array is {@code null} or empty, and
     * throwing an {@link IllegalArgumentException} if not.
     *
     * @param array   the array checked to be {@code null} or empty
     * @param messageSupplier  the custom supplier to be used to get the message in case of a violation
     *
     * @throws IllegalArgumentException if the given array contains any element
     */
    public static void isNullOrEmpty(final Object[] array, final Supplier<String> messageSupplier) {
        if (array != null && array.length > 0) {
            throw illegalArgumentException(messageSupplier, ENSURE_ARGUMENT_IS_NULL_OR_EMPTY_FAILED);
        }
    }

    public static void fileExists(final File file) {
        if (!file.exists()) {
            throw new IllegalArgumentException("File " + file.getName() + " exists not.");
        }
    }


    // the following Validate methods are not (yet) in EnsureState


    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument collection is null
     * or has elements that are not of type clazz or a subclass.
     *
     * @param collection    the collection to be checked
     * @param clazz         the clazz each element of the collection should be the type of
     *
     * @throws IllegalArgumentException if {@code (collection == null)} or any collection element of is not of type
     *                                  {@code clazz}.
     */
    public static void allElementsOfType(final Collection<?> collection, final Class<?> clazz) {
        Validate.allElementsOfType(collection, clazz);
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument collection is null
     * or has elements that are not of type clazz or a subclass and using a custom message if the
     * constraint has been violated.
     *
     * @param collection    the collection to be checked
     * @param clazz         the clazz each element of the collection should be the type of
     * @param message       the custom message to be used in case of a violation
     */
    public static void allElementsOfType(final Collection<?> collection, final Class<?> clazz, final String message) {
        Validate.allElementsOfType(collection, clazz, message);
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument Collection has null elements or is null
     *
     * @param collection    the collection to be checked
     */
    public static void noNullElements(final Iterable<?> collection) {
        Validate.notNull(collection);
        for (Object each : collection) {
            Validate.notNull(each);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument Collection has null elements or is null
     * and using a custom message if the constraint has been violated.
     *
     * @param collection    the collection to be checked
     * @param message       the custom message to be used in case of a violation
     */
    public static void noNullElements(final Iterable<?> collection, final String message) {
        Validate.notNull(collection);
        for (Object each : collection) {
            Validate.notNull(each, message);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument Collection has elements that are converted to null or the collection itself is null
     * and using a custom message if the constraint has been violated.
     *
     * @param collection    the collection to be checked
     * @param message       the custom message to be used in case of a violation
     */
    public static <T, E> void noNullElements(final Iterable<T> collection, Function<T, E> converter, final String message) {
        Validate.notNull(collection);
        for (T each : collection) {
            E converted = converter.apply(each);
            Validate.notNull(converted, message);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument array has null elements or is null.
     *
     * @param array         the array to be checked
     */
    public static void noNullElements(final Object[] array) {
        Validate.noNullElements(array);
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument array has null elements or is null
     * and using a custom message if the constraint has been violated.
     *
     * @param array         the array to be checked
     * @param message       the custom message to be used in case of a violation
     */
    public static void noNullElements(final Object[] array, final String message) {
        Validate.noNullElements(array, message);
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument map has null keys or values or is null
     * and using a custom message if the constraint has been violated.
     *
     * @param map        the map to be checked
     * @param message    the custom message to be used in case of a violation
     */
    public static void noNullElements(final Map<?, ?> map, final String message) {
        Validate.notNull(map);
        for (Map.Entry<?, ?> entry : map.entrySet()) {
            Validate.notNull(entry.getKey(), message);
            Validate.notNull(entry.getValue(), message);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument map has null keys or is null
     * and using a custom message if the constraint has been violated.
     *
     * @param map        the map to be checked
     * @param message    the custom message to be used in case of a violation
     */
    public static void noNullKeys(final Map<?, ?> map, final String message) {
        Validate.notNull(map);
        for (Map.Entry<?, ?> entry : map.entrySet()) {
            Validate.notNull(entry.getKey(), message);
        }
    }


    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument Collection is not of the expected size (or null)
     * and using a custom message if the constraint has been violated.
     *
     * @param collection    the collection to be checked
     * @param size          expected size
     * @param message       the custom message to be used in case of a violation
     */
    public static void hasSize(final Collection<?> collection, final int size, final String message) {
        Validate.notNull(collection);
        Validate.isTrue(collection.size() == size, message);
    }



    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument {@code elements} has null or blank elements
     * and using a custom message if the constraint has been violated.
     *
     * @param elements      the elements to be checked
     * @param message       the custom message to be used in case of a violation
     */
    public static void noBlankElements(final Iterable<String> elements, final String message) {
        Validate.notNull(elements);
        for (String element : elements) {
            notBlank(element, message);
        }
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument String is empty after trimming (null or zero length).
     *
     * @param string    the string to be checked
     */
    public static void hasText(final String string) {
        Validate.notEmpty(StringUtils.trim(string));
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument String is empty after trimming (null or zero length)
     * and using a custom message if the constraint has been violated.
     *
     * @param string    the string to be checked
     * @param message   the custom message to be used in case of a violation
     */
    public static void hasText(final String string, final String message) {
        Validate.notEmpty(StringUtils.trim(string), message);
    }


    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument is
     * <strong>not</strong> in the given range {@code start <= i <= end}. objectName is used to build a meaningful message.
     *
     * @param object
     * @param start
     * @param end
     * @param objectName
     */
    public static void isInRange(final int object, final int start, final int end, final String objectName) {
        Validate.isTrue(start <= object && object <= end,
                        objectName + " must be in range from '" + start + "' to '" + end + "'!");
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument is
     * <strong>not</strong> in the given range {@code start <= i <= end}. objectName is used to build a meaningful message.
     *
     * @param object
     * @param start
     * @param end
     * @param objectName
     * @return the given object
     */
    public static int checkRange(final int object, final int start, final int end, final String objectName) {
        isInRange(object, start, end, objectName);
        return object;
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument is
     * <strong>not</strong> in the given range {@code start <= i <= end}. objectName is used to build a meaningful message.
     *
     * @param object
     * @param start
     * @param end
     * @param objectName
     */
    public static void isInRange(final double object, final double start, final double end, final String objectName) {
        Validate.isTrue(start <= object && object <= end,
                        objectName + " must be in range from '" + start + "' to '" + end + "'!");
    }

    /**
     * Validate an argument, throwing {@code IllegalArgumentException} if the argument is
     * <strong>not</strong> one of the specified expected values
     * @param obj Object to check. May be null.
     * @param expected Valid values.
     */
    public static <T> void equalsAny(final T obj, final Collection<T> expected) {
        notEmpty(expected, "no expected objects specified");
        for (Object other : expected) {
            if (ObjectUtils.equals(obj, other)) {
                return;
            }
        }
        throw new IllegalArgumentException(String.format("got object '%s'; expected one of: %s", obj, StringUtils.join(expected, ", ")));
    }

    /**
     * Validates that an argument contains each element at most once.
     *
     * @param iterable  the iterable to validate
     * @param message   the message for the exception
     */
    public static <T, R> void allElementsUnique(Iterable<T> iterable, String message) {
        allElementsUnique(iterable, Function.identity(), message);
    }

    /**
     * Validates that an argument contains each element at most once.
     *
     * @param iterable  the iterable to validate
     * @param converter a converter
     * @param message   the message for the exception
     */
    public static <T, R> void allElementsUnique(Iterable<T> iterable, Function<T, R> converter, String message) {
        Set<R> seenElements = newHashSet();
        for (T current : iterable) {
            R convertedElement = converter.apply(current);
            if (seenElements.contains(convertedElement)) {
                throw new IllegalArgumentException(message);
            }
            seenElements.add(convertedElement);
        }
    }
    
    /**
     * Ensure that the argument matches the given pattern,
     * throwing {@code IllegalArgumentException} if not
     * 
     * <p><strong>Note:</strong> {@code NULL}-values will be ignored.</p>
     *
     * @param pattern  the pattern to check against
     * @param value    the value to check
     * 
     * @throws IllegalArgumentException in case of violation
     */
    public static void matchesIfNotNull(final Pattern pattern, final String value) {
        if (value == null) {
            return;
        }
        
        isTrue(pattern.matcher(value).matches());
    }

    /**
     * Ensure that the argument matches the given pattern,
     * throwing {@code IllegalArgumentException} if not
     * 
     * <p><strong>Note:</strong> {@code NULL}-values will be ignored.</p>
     *
     * @param pattern  the pattern to check against
     * @param value    the value to check
     * @param message  the custom message to be used in case of a violation
     * 
     * @throws IllegalArgumentException in case of violation
     */
    public static void matchesIfNotNull(final Pattern pattern, final String value, final String message) {
        if (value == null) {
            return;
        }
        
        isTrue(pattern.matcher(value).matches(), message);
    }

}